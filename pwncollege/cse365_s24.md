# CSE 365 Spring 2024

- [Talking Web](#talking-web)
- [Assembly Crash Course](#assembly-crash-course)
- [Building a Web Server](#building-a-web-server)

## Talking Web

## Assembly Crash Course

## Building a Web Server
- CPUs contain registers, have a small amount of memory, and can perform a lot of operations.
- We are **not** allowed to manipulate hardware directly, instead we have to talk with the **OS** using `syscalls`.
- The **kernal memory** keeps track of the state of processes.
    - located at the bottom of memory (high addresses)
    - processes are just **data** in kernal memory
    - `syscalls` manipulate kernal memory
- `struct task_struct` is a blob is data managing the state of a process.
- `struct task_struct *current` is a **global** variable that keeps track of the **current executing process**.
- `socket` creates an endpoint for communication
- `bind` assigns an address to a socket
    - the address follows the structure
        ```C
        struct sockaddr_in {
            uint16_t sa_family;
            uint8_t sa_data[14];
        };
        ```
    - `uint16_t` represents 2 bytes
    - `uint8_t` represents 1 byte
    - the address structure for **Internet** is
        ```C
        struct sockaddr_in {
            uint16_t sin_family;
            uint16_t sin_port;
            uint32_t sin_addr;
            uint8_t __pad[8];
        };
        ```
        - `AF_INET` has value `2` and is a part of `sin_family`.
        - `htons`, host to network, converts little-endian to big-endian.
        - `0.0.0.0` binds to any network interface.
- Networking likes to work in **big-endian**.
- `listen` listens for incoming connection requests and puts them into a backlog queue.
- `accept` extracts first connection request on queue and creates a new connected socket, returning a new FD for it.
- `fork` creates a new child process by **duplicating** the calling parent process
    - on success, `PID` of child is returned to the parent and `0` is returned to child
    - both processes will run the same code

### Problems
In this series of challenges, you will be writing assembly to interact with your environment, and ultimately build a web server. 

All solutions will be in `server.s`. Every level has the following boilerplate. We include what is necessary for conciseness in the challenge solutions. We use this [table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) and `man 2 <command>` for help.
```assembly
.intel_syntax noprefix
.globl _start

.section .text

_start:

.section .data
```
Compile the assembly code and submit to get the flag:
```
as -o server.o server.s && ld -o server server.o && /challenge/run ./server
```
### Level 1
In this challenge you will exit a program.
```assembly
# Exit program
mov rax, 60
mov rdi, 0
syscall
```
### Level 2
In this challenge you will create a socket.

Specifically, the level wants `socket(AF_INET, SOCK_STREAM, IPPROTO_IP)`.
```assembly
# Create TCP/IP socket
mov rax, 41
mov rdi, 2
mov rsi, 1
mov rdx, 0
syscall

mov r10, rax    # r10: Socket FD

# Exit program
```
### Level 3
In this challenge you will bind an address to a socket. 

Specifically, the level wants 

`bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16)`. 

Note that the arguments for **bind** are given by 

`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`,

and **sockaddr** is defined as

`struct sockaddr {sa_family_t sa_family; char sa_data[14];}`.

The structure for **sockaddr_in** is 

`struct sockaddr_in {uint16_t sin_family; uint16_t sin_port; uint32_t sin_addr; uint8_t __pad[8];}`.
```assembly
# var sockaddr_in
.section .data
sockaddr_in:
    .2byte 2
    .byte 0
    .byte 80
    .4byte 0
    .8byte 0

# Create TCP/IP socket
# r10: Socket FD

# Bind 0.0.0.0:80 to socket
mov rax, 49
mov rdi, r10
mov rsi, offset sockaddr_in     # lea rsi, sockaddr_in
mov rdx, 16
syscall

# Exit program
```
### Level 4
In this challenge you will listen on a socket.

Specifically, the level wants `listen(3, 0) = 0`.
```assembly
# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket

# Listen on socket
mov rax, 50
mov rdi, r10
mov rsi, 0
syscall

# Exit program
```
### Level 5
In this challenge you will accept a connection.

Specifically, the level wants `accept(3, NULL, NULL) = 4`.
```assembly
# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket
# Listen on socket

# Accept a connection
mov rax, 43
mov rdi, r10 
mov rsi, 0
mov rdx, 0
syscall

mov r12, rax    # r12: Connected socket FD

# Exit program
```
### Level 6
In this challenge you will respond to an http request.

Specifically, the level wants
```
read(4, <read_request>, <read_request_count>) = <read_request_result>
write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
close(4) = 0
```
```assembly
# var response
.section .data
response:
    .ascii "HTTP/1.0 200 OK\r\n\r\n"

# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket
# Listen on socket
# Accept a connection
# r12: Connected socket FD

# Read to rsp from connected socket
mov rax, 0
mov rdi, r12
mov rsi, rsp 
mov rdx, 256 
syscall

# Write HTTP response to connected socket
mov rax, 1
mov rsi, offset response
mov rdx, 19
syscall

# Close connected socket
mov rax, 3
syscall

# Exit program
```
There is an error when I include `mov rdi, r11` in `Write` and `Close`. It is because syscalls clobber the `r11` register.

### Level 7
In this challenge you will respond to a GET request for the contents of a specified file.
```assembly

```
### Level 8
In this challenge you will accept multiple requests.
```assembly

```
### Level 9
In this challenge you will concurrently accept multiple requests.
```assembly

```
A `fork` syscall along with a `cmp` to separate child and parent process code is the main idea for this level.
### Level 10
In this challenge you will respond to a POST request with a specified file and update its contents.
```assembly

```

### Level 11
In this challenge you will respond to multiple concurrent GET and POST requests.
```assembly
.intel_syntax noprefix
.global _start

.section .text

_start:

mov rax, 41
mov rdi, 2
mov rsi, 1
mov rdx, 0
syscall
mov r12, rax
mov rax, 49
mov rdi, r12
mov rsi, offset sockaddr_in
mov rdx, 16
syscall
mov rax, 50
mov rdi, r12
mov rsi, 0
syscall


ACCEPT_LOOP:
mov rax, 43
mov rdi, r12
mov rsi, 0
mov rdx, 0
syscall
mov r13, rax

mov rax, 57
syscall

cmp rax, 0
jne parent

# ========= CHILD ============

# close(3) = 0
mov rax, 3
mov rdi, r12
syscall

# read(4, <read_request>, <read_request_count>)
mov rax, 0
mov rdi, r13
mov rsi, rsp
mov rdx, 500
syscall
mov r10, rax

# Get file path
mov rcx, 0
filepath_loop:
    mov al, [rsp+rcx]
    cmp al, 0x20
    je filepath_space
    inc rcx
    jmp filepath_loop
filepath_space:
    inc rcx
    lea r8, [rsp+rcx]
filepath_loop2:
    mov al, [rsp+rcx]
    cmp al, 0x20
    je filepath_space2
    inc rcx
    jmp filepath_loop2
filepath_space2:
    mov byte ptr [rsp+rcx], 0

# GET or POST method
cmp byte ptr [rsp], 0x50
jne GET

# open("<open_path>", O_WRONLY|O_CREAT, 0777)
mov rax, 2
mov rdi, r8
mov rsi, 65
mov rdx, 0777
syscall
mov r14, rax

# Get write content
mov rcx, 0
first:
mov al, [rsp+rcx]
cmp al, 0xD
je second
inc rcx
jmp first
second:
inc rcx
mov al, [rsp+rcx]
cmp al, 0xA
je third
inc rcx
jmp first
third:
inc rcx
mov al, [rsp+rcx]
cmp al, 0xD
je done
inc rcx
jmp first
done:
add rcx, 2
lea r9, [rsp+rcx]
sub r10, rcx

# write(3, <write_file>, <write_file_count>)
mov rax, 1
mov rdi, r14
mov rsi, r9
mov rdx, r10
syscall

# close(3)
mov rax, 3
mov rdi, r14
syscall

# write(4, "HTTP/1.0 200 OK\r\n\r\n", 19)
mov rax, 1
mov rdi, r13 
mov rsi, offset response
mov rdx, 19
syscall 

jmp EXIT

GET:
# open("<open_path>", O_RDONLY)
mov rax, 2
mov rdi, r8
mov rsi, 0
mov rdx, 0
syscall
mov r14, rax

# read(3, <read_file>, <read_file_count>)
mov rax, 0
mov rdi, r14
mov rsi, rsp
mov rdx, 256
syscall
mov r15, rax

# close(3)
mov rax, 3
mov rdi, r14
syscall

# write(4, "HTTP/1.0 200 OK\r\n\r\n", 19)
mov rax, 1
mov rdi, r13
mov rsi, offset response
mov rdx, 19
syscall

# write(4, <write_file>, <write_file_count>)
mov rax, 1
mov rdi, r13
mov rsi, rsp
mov rdx, r15
syscall

EXIT: 
# exit(0)
mov rax, 60
mov rdi, 0
syscall

# ============================

parent:
mov rax, 3
mov rdi, r13
syscall

jmp ACCEPT_LOOP

.section .data
sockaddr_in:
    .2byte 2
    .byte 0
    .byte 80
    .4byte 0
    .8byte 0
response:
    .ascii "HTTP/1.0 200 OK\r\n\r\n"
```