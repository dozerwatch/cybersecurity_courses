# CSE 365 Spring 2024

- [Talking Web](#talking-web)
- [Assembly Crash Course](#assembly-crash-course)
- [Building a Web Server](#building-a-web-server)

## Talking Web

## Assembly Crash Course

## Building a Web Server
- CPUs contain registers, have a small amount of memory, and can perform a lot of operations.
- We are **not** allowed to manipulate hardware directly, instead we have to talk with the **OS** using `syscalls`.
- The **kernal memory** keeps track of the state of processes.
    - located at the bottom of memory (high addresses)
    - processes are just **data** in kernal memory
    - `syscalls` manipulate kernal memory
- `struct task_struct` is a blob is data managing the state of a process.
- `struct task_struct *current` is a **global** variable that keeps track of the **current executing process**.
- `socket` creates an endpoint for communication
- `bind` assigns an address to a socket
    - the address follows the structure
        ```C
        struct sockaddr_in {
            uint16_t sa_family;
            uint8_t sa_data[14];
        };
        ```
    - `uint16_t` represents 2 bytes
    - `uint8_t` represents 1 byte
    - the address structure for **Internet** is
        ```C
        struct sockaddr_in {
            uint16_t sin_family;
            uint16_t sin_port;
            uint32_t sin_addr;
            uint8_t __pad[8];
        };
        ```
        - `AF_INET` has value `2` and is a part of `sin_family`.
        - `htons`, host to network, converts little-endian to big-endian.
        - `0.0.0.0` binds to any network interface.
- Networking likes to work in **big-endian**.
- `listen` listens for incoming connection requests and puts them into a backlog queue.
- `accept` extracts first connection request on queue and creates a new connected socket, returning a new FD for it.
- `fork` creates a new child process by **duplicating** the calling parent process
    - on success, `PID` of child is returned to the parent and `0` is returned to child
    - both processes will run the same code

### Problems
In this series of challenges, you will be writing assembly to interact with your environment, and ultimately build a web server. 

All solutions will be in `server.s`. Every level has the following boilerplate. We include what is necessary for conciseness in the challenge solutions. We use this [table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) and `man 2 <command>` for help.
```assembly
.intel_syntax noprefix
.global _start

.section .text

.section .data

_start:
```
Compile the assembly code and submit to get the flag:
```
as -o server.o server.s && ld -o server server.o
/challenge/run ./server
```
### Level 1
In this challenge you will exit a program.
```assembly
# Exit program
mov rax, 60
mov rdi, 0
syscall
```
### Level 2
In this challenge you will create a socket.

Specifically, the level wants `socket(AF_INET, SOCK_STREAM, IPPROTO_IP)`.
```assembly
# Create TCP/IP socket
mov rax, 41
mov rdi, 2
mov rsi, 1
mov rdx, 0
syscall

mov r10, rax    # r10: Socket FD

# Exit program
```
### Level 3
In this challenge you will bind an address to a socket. 

Specifically, the level wants 

`bind(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("0.0.0.0")}, 16)`. 

Note that the arguments for **bind** are given by 

`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`,

and **sockaddr** is defined as

`struct sockaddr {sa_family_t sa_family; char sa_data[14];}`.

The structure for **sockaddr_in** is 

`struct sockaddr_in {uint16_t sin_family; uint16_t sin_port; uint32_t sin_addr; uint8_t __pad[8];}`.
```assembly
# var sockaddr_in
.section .data
sockaddr_in:
    .2byte 2
    .byte 0
    .byte 80
    .4byte 0
    .8byte 0

# Create TCP/IP socket
# r10: Socket FD

# Bind 0.0.0.0:80 to socket
mov rax, 49
mov rdi, r10
mov rsi, offset sockaddr_in     # lea rsi, sockaddr_in
mov rdx, 16
syscall

# Exit program
```
### Level 4
In this challenge you will listen on a socket.

Specifically, the level wants `listen(3, 0) = 0`.
```assembly
# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket

# Listen on socket
mov rax, 50
mov rdi, r10
mov rsi, 0
syscall

# Exit program
```
### Level 5
In this challenge you will accept a connection.

Specifically, the level wants `accept(3, NULL, NULL) = 4`.
```assembly
# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket
# Listen on socket

# Accept a connection
mov rax, 43
mov rdi, r10 
mov rsi, 0
mov rdx, 0
syscall

mov r11, rax    # r11: Connected socket FD

# Exit program
```
### Level 6
In this challenge you will respond to an http request.

Specifically, the level wants
```
read(4, <read_request>, <read_request_count>) = <read_request_result>
write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
close(4) = 0
```
```assembly
# var response
.section .text
response:
    .ascii "HTTP/1.0 200 OK\r\n\r\n"

# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket
# Listen on socket
# Accept a connection
# r11: Connected socket FD

# Read to rsp from r11
mov rax, 0
mov rdi, r11 
mov rsi, rsp 
mov rdx, 256 
syscall

# Write response to r11
mov rax, 1
mov rsi, offset response
mov rdx, 19
syscall

# Close r11
mov rax, 3
syscall

# Exit program
```
There is an error when I include `mov rdi, r11` in `Write` and `Close`. The file descriptor changes and I don't know why. My thinking is that the `Read` syscall somehow changes `r11`.
### Level 7
In this challenge you will respond to a GET request for the contents of a specified file.
```
open("<open_path>", O_RDONLY) = 5
read(5, <read_file>, <read_file_count>) = <read_file_result>
close(5) = 0
write(4, <write_file>, <write_file_count>) = <write_file_result>
```
```assembly
# var response
# var sockaddr_in
# Create TCP/IP socket
# r10: Socket FD
# Bind 0.0.0.0:80 to socket
# Listen on socket
# Accept a connection
# r11: Connected socket FD
# Read to rsp from r11
# Write response to r11
# Close r11
# Exit program
```
