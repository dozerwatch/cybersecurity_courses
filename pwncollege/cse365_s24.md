# CSE 365 Spring 2024

- [Assembly Crash Course](#assembly-crash-course)
- [Building a Web Server](#building-a-web-server)

## Assembly Crash Course

## Building a Web Server
- CPUs contain registers, have a small amount of memory, and can perform a lot of operations.
- We are **not** allowed to manipulate hardware directly, instead we have to talk with the **OS** using `syscalls`.
- The **kernal memory** keeps track of the state of processes.
    - located at the bottom of memory (high addresses)
    - processes are just **data** in kernal memory
    - `syscalls` manipulate kernal memory
- `struct task_struct` is a blob is data managing the state of a process.
- `struct task_struct *current` is a **global** variable that keeps track of the **current executing process**.
- `socket` creates an endpoint for communication
- `bind` assigns an address to a socket
    - the address follows the structure
        ```C
        struct sockaddr_in {
            uint16_t sa_family;
            uint8_t sa_data[14];
        };
        ```
    - `uint16_t` represents 2 bytes
    - `uint8_t` represents 1 byte
    - the address structure for **Internet** is
        ```C
        struct sockaddr_in {
            uint16_t sin_family;
            uint16_t sin_port;
            uint32_t sin_addr;
            uint8_t __pad[8];
        };
        ```
        - `AF_INET` has value `2` and is a part of `sin_family`.
        - `htons`, host to network, converts little-endian to big-endian.
        - `0.0.0.0` binds to any network interface.
- Networking likes to work in **big-endian**.
- `listen` listens for incoming connection requests and puts them into a backlog queue.
- `accept` extracts first connection request on queue and creates a new connected socket, returning a new FD for it.
- `fork` creates a new child process by **duplicating** the calling parent process
    - on success, `PID` of child is returned to the parent and `0` is returned to child
    - both processes will run the same code

### Problems
In this series of challenges, you will be writing assembly to interact with your environment, and ultimately build a web server. 

We use this [table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) and `man 2 <command>` for help.

### Level 11
In this challenge you will respond to multiple concurrent GET and POST requests.
```assembly
.intel_syntax noprefix
.global _start

.section .text

_start:

mov rax, 41
mov rdi, 2
mov rsi, 1
mov rdx, 0
syscall
mov r12, rax
mov rax, 49
mov rdi, r12
mov rsi, offset sockaddr_in
mov rdx, 16
syscall
mov rax, 50
mov rdi, r12
mov rsi, 0
syscall


ACCEPT_LOOP:
mov rax, 43
mov rdi, r12
mov rsi, 0
mov rdx, 0
syscall
mov r13, rax

mov rax, 57
syscall

cmp rax, 0
jne parent

# ========= CHILD ============

# close(3) = 0
mov rax, 3
mov rdi, r12
syscall

# read(4, <read_request>, <read_request_count>)
mov rax, 0
mov rdi, r13
mov rsi, rsp
mov rdx, 500
syscall
mov r10, rax

# Get file path
mov rcx, 0
filepath_loop:
    mov al, [rsp+rcx]
    cmp al, 0x20
    je filepath_space
    inc rcx
    jmp filepath_loop
filepath_space:
    inc rcx
    lea r8, [rsp+rcx]
filepath_loop2:
    mov al, [rsp+rcx]
    cmp al, 0x20
    je filepath_space2
    inc rcx
    jmp filepath_loop2
filepath_space2:
    mov byte ptr [rsp+rcx], 0

# GET or POST method
cmp byte ptr [rsp], 0x50
jne GET

# open("<open_path>", O_WRONLY|O_CREAT, 0777)
mov rax, 2
mov rdi, r8
mov rsi, 65
mov rdx, 0777
syscall
mov r14, rax

# Get write content
mov rcx, 0
first:
mov al, [rsp+rcx]
cmp al, 0xD
je second
inc rcx
jmp first
second:
inc rcx
mov al, [rsp+rcx]
cmp al, 0xA
je third
inc rcx
jmp first
third:
inc rcx
mov al, [rsp+rcx]
cmp al, 0xD
je done
inc rcx
jmp first
done:
add rcx, 2
lea r9, [rsp+rcx]
sub r10, rcx

# write(3, <write_file>, <write_file_count>)
mov rax, 1
mov rdi, r14
mov rsi, r9
mov rdx, r10
syscall

# close(3)
mov rax, 3
mov rdi, r14
syscall

# write(4, "HTTP/1.0 200 OK\r\n\r\n", 19)
mov rax, 1
mov rdi, r13 
mov rsi, offset response
mov rdx, 19
syscall 

jmp EXIT

GET:
# open("<open_path>", O_RDONLY)
mov rax, 2
mov rdi, r8
mov rsi, 0
mov rdx, 0
syscall
mov r14, rax

# read(3, <read_file>, <read_file_count>)
mov rax, 0
mov rdi, r14
mov rsi, rsp
mov rdx, 256
syscall
mov r15, rax

# close(3)
mov rax, 3
mov rdi, r14
syscall

# write(4, "HTTP/1.0 200 OK\r\n\r\n", 19)
mov rax, 1
mov rdi, r13
mov rsi, offset response
mov rdx, 19
syscall

# write(4, <write_file>, <write_file_count>)
mov rax, 1
mov rdi, r13
mov rsi, rsp
mov rdx, r15
syscall

EXIT: 
# exit(0)
mov rax, 60
mov rdi, 0
syscall

# ============================

parent:
mov rax, 3
mov rdi, r13
syscall

jmp ACCEPT_LOOP

.section .data
sockaddr_in:
    .2byte 2
    .byte 0
    .byte 80
    .4byte 0
    .8byte 0
response:
    .ascii "HTTP/1.0 200 OK\r\n\r\n"
```